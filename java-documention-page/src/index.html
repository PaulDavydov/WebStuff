<nav id="navbar">
  <header> JAVA Documentation</header>
  <a href="#Introduction">Introduction</a>
  <a href="#Object">Object</a>
  <a href="#Class">Class</a>
  <a href="#Inheritance">Inheritance</a>
  <a href="#Interface">Interface</a>
  <a href="#Variables">Variables</a>
  <a href="#Operators">Operators</a>
  <a href="#Reference">Reference</a>
</nav>

<main id="main-doc">
  <section id="Introduction" class="main-section">
    <h1>Introduction</h1>
    <p>The general-purpose, high-level Java programming language is a powerful software platform. Every full implementation of the Java platform gives you the following features</P>
    <ul>
      <li>Development Tools: The development tools provide everything you'll need for compiling, running, monitoring, debugging, and documenting your applications. As a new developer, the main tools you'll be using are the javac compiler, the java launcher, and the javadoc documentation tool.</li>
      <li>Application Programming Interface (API): The API provides the core functionality of the Java programming language. It offers a wide array of useful classes ready for use in your own applications. It spans everything from basic objects, to networking and security, to XML generation and database access, and more. The core API is very large; to get an overview of what it contains, consult the Java Platform Standard Edition 8 Documentation.</li>
      <li>Deployment Technologies: The JDK software provides standard mechanisms such as the Java Web Start software and Java Plug-In software for deploying your applications to end users.</li>
      <li>User Interface Toolkits: The JavaFX, Swing, and Java 2D toolkits make it possible to create sophisticated Graphical User Interfaces (GUIs).</li>
      <li>Integration Libraries: Integration libraries such as the Java IDL API, JDBC API, Java Naming and Directory Interface (JNDI) API, Java RMI, and Java Remote Method Invocation over Internet Inter-ORB Protocol Technology (Java RMI-IIOP Technology) enable database access and manipulation of remote objects.</li>
    </ul> 
  </section>
  
  <section id="Object" class="main-section">
    <h1>Object</h1>
    <p>Objects are key to understanding object-oriented technology. Look around right now and you'll find many examples of real-world objects: your dog, your desk, your television set, your bicycle.</p>
    <p>Real-world objects share two characteristics: They all have state and behavior. Dogs have state (name, color, breed, hungry) and behavior (barking, fetching, wagging tail). Bicycles also have state (current gear, current pedal cadence, current speed) and behavior (changing gear, changing pedal cadence, applying brakes). Identifying the state and behavior for real-world objects is a great way to begin thinking in terms of object-oriented programming.</p>
    <p>Take a minute right now to observe the real-world objects that are in your immediate area. For each object that you see, ask yourself two questions: "What possible states can this object be in?" and "What possible behavior can this object perform?". Make sure to write down your observations. As you do, you'll notice that real-world objects vary in complexity; your desktop lamp may have only two possible states (on and off) and two possible behaviors (turn on, turn off), but your desktop radio might have additional states (on, off, current volume, current station) and behavior (turn on, turn off, increase volume, decrease volume, seek, scan, and tune). You may also notice that some objects, in turn, will also contain other objects. These real-world observations all translate into the world of object-oriented programming.</p>
    <img src="https://docs.oracle.com/javase/tutorial/figures/java/concepts-object.gif">
    <p>Software objects are conceptually similar to real-world objects: they too consist of state and related behavior. An object stores its state in fields (variables in some programming languages) and exposes its behavior through methods (functions in some programming languages). Methods operate on an object's internal state and serve as the primary mechanism for object-to-object communication. Hiding internal state and requiring all interaction to be performed through an object's methods is known as data encapsulation — a fundamental principle of object-oriented programming.</p>
    <p>Consider a bicycle, for example:</p>
    <img src="https://docs.oracle.com/javase/tutorial/figures/java/concepts-bicycleObject.gif">
    <p>By attributing state (current speed, current pedal cadence, and current gear) and providing methods for changing that state, the object remains in control of how the outside world is allowed to use it. For example, if the bicycle only has 6 gears, a method to change gears could reject any value that is less than 1 or greater than 6.</p>
    <p>Bundling code into individual software objects provides a number of benefits, including:</p>
    <ol>
      <li>Modularity: The source code for an object can be written and maintained independently of the source code for other objects. Once created, an object can be easily passed around inside the system.</li>
      <li>Information-hiding: By interacting only with an object's methods, the details of its internal implementation remain hidden from the outside world.</li>
      <li>Code re-use: If an object already exists (perhaps written by another software developer), you can use that object in your program. This allows specialists to implement/test/debug complex, task-specific objects, which you can then trust to run in your own code.</li>
      <li>Pluggability and debugging ease: If a particular object turns out to be problematic, you can simply remove it from your application and plug in a different object as its replacement. This is analogous to fixing mechanical problems in the real world. If a bolt breaks, you replace it, not the entire machine.</li>
    </ol>
  </section>
  
  <section id="Class" class="main-section">
    <h1>Class</h1>
    <p>In the real world, you'll often find many individual objects all of the same kind. There may be thousands of other bicycles in existence, all of the same make and model. Each bicycle was built from the same set of blueprints and therefore contains the same components. In object-oriented terms, we say that your bicycle is an instance of the class of objects known as bicycles. A class is the blueprint from which individual objects are created.</p>
    <p>The following <code>Bicycle</code> class is one possible implementation of a bicycle:</p>
    <pre>
      <code>
        class Bicycle {
        
          int cadence = 0;
          int speed = 0;
          int gear = 1;
          
            void changeCadence(int newValue) {
              cadence = newValue;
            }

            void changeGear(int newValue) {
              gear = newValue;
            }

            void speedUp(int increment) {
              speed = speed + increment;
            }

            void applyBrakes(int decrement) {
              speed = speed - decrement;
            }

            void printStates() {
              System.out.println("cadence:" +
              cadence + " speed:" + 
              speed + " gear:" + gear);
            }
          }
      </code>
    </pre>
    <p>The syntax of the Java programming language will look new to you, but the design of this class is based on the previous discussion of bicycle objects. The fields cadence, speed, and gear represent the object's state, and the methods (changeCadence, changeGear, speedUp etc.) define its interaction with the outside world.</p>
    <p>You may have noticed that the Bicycle class does not contain a main method. That's because it's not a complete application; it's just the blueprint for bicycles that might be used in an application. The responsibility of creating and using new Bicycle objects belongs to some other class in your application.</p>
    <p>Here's a <code>BicycleDemo</code> class that creates two separate Bicycle objects and invokes their methods:</p>
    <pre>
      <code>
        class BicycleDemo {
          public static void main(String[] args) {

          // Create two different 
          // Bicycle objects
          Bicycle bike1 = new Bicycle();
          Bicycle bike2 = new Bicycle();

          // Invoke methods on 
          // those objects
          bike1.changeCadence(50);
          bike1.speedUp(10);
          bike1.changeGear(2);
          bike1.printStates();

          bike2.changeCadence(50);
          bike2.speedUp(10);
          bike2.changeGear(2);
          bike2.changeCadence(40);
          bike2.speedUp(10);
          bike2.changeGear(3);
          bike2.printStates();
        }
      }
      </code>
    </pre>
    <p>The output of this test prints the ending pedal cadence, speed, and gear for the two bicycles:</p>
    <pre>
      <code>
        cadence:50 speed:10 gear:2
        cadence:40 speed:20 gear:3
      </code>
    </pre>
  </section>
  
  <section id="Inheritance"class="main-section">
    <h1>Inheritance</h1>
    <p>Different kinds of objects often have a certain amount in common with each other. Mountain bikes, road bikes, and tandem bikes, for example, all share the characteristics of bicycles (current speed, current pedal cadence, current gear). Yet each also defines additional features that make them different: tandem bicycles have two seats and two sets of handlebars; road bikes have drop handlebars; some mountain bikes have an additional chain ring, giving them a lower gear ratio.</p>
    <p>Object-oriented programming allows classes to inherit commonly used state and behavior from other classes. In this example, <code>Bicycle</code> now becomes the superclass of <code>MountainBike</code>, <code>RoadBike</code>, and <code>TandemBike</code>. In the Java programming language, each class is allowed to have one direct superclass, and each superclass has the potential for an unlimited number of subclasses:</p>
    <img src="https://docs.oracle.com/javase/tutorial/figures/java/concepts-bikeHierarchy.gif">
    <p>The syntax for creating a subclass is simple. At the beginning of your class declaration, use the extends keyword, followed by the name of the class to inherit from:</p>
    <pre>
      <code>
        class MountainBike extends Bicycle {

          // new fields and methods defining 
          // a mountain bike would go here

        }
      </code>
    </pre>
    <p>This gives <code>MountainBike</code> all the same fields and methods as <code>Bicycle</code>, yet allows its code to focus exclusively on the features that make it unique. This makes code for your subclasses easy to read. However, you must take care to properly document the state and behavior that each superclass defines, since that code will not appear in the source file of each subclass.</p>
  </section>
  
  <section id="Interface" class="main-section">
    <h1>Interface</h1>
    <p>As you've already learned, objects define their interaction with the outside world through the methods that they expose. Methods form the object's interface with the outside world; the buttons on the front of your television set, for example, are the interface between you and the electrical wiring on the other side of its plastic casing. You press the "power" button to turn the television on and off.</p>
    <p>In its most common form, an interface is a group of related methods with empty bodies. A bicycle's behavior, if specified as an interface, might appear as follows:</p>
    <pre>
      <code>
        interface Bicycle {

          //  wheel revolutions per minute
          void changeCadence(int newValue);

          void changeGear(int newValue);

          void speedUp(int increment);

          void applyBrakes(int decrement);
        }
      </code>
    </pre>
    <p>To implement this interface, the name of your class would change (to a particular brand of bicycle, for example, such as <code>ACMEBicycle</code>), and you'd use the implements keyword in the class declaration:</p>
    <pre>
      <code>
       class ACMEBicycle implements Bicycle {

        int cadence = 0;
        int speed = 0;
        int gear = 1;

        // The compiler will now require that methods
        // changeCadence, changeGear, speedUp, and applyBrakes
        // all be implemented. Compilation will fail if those
        // methods are missing from this class.

        void changeCadence(int newValue) {
          cadence = newValue;
        }

        void changeGear(int newValue) {
          gear = newValue;
        }

        void speedUp(int increment) {
          speed = speed + increment;   
        }

        void applyBrakes(int decrement) {
          speed = speed - decrement;
        }

        void printStates() {
          System.out.println("cadence:" +
              cadence + " speed:" + 
              speed + " gear:" + gear);
        }
      }    
      </code>
    </pre>
    <p>Implementing an interface allows a class to become more formal about the behavior it promises to provide. Interfaces form a contract between the class and the outside world, and this contract is enforced at build time by the compiler. If your class claims to implement an interface, all methods defined by that interface must appear in its source code before the class will successfully compile.</p>
    
  </section>
  
  <section id="Variables" class="main-section">
    <h1>Variables</h1>
    <p>The Java programming language defines the following kinds of variables:</p>
    <ul>
      <li>Instance Variables (Non-Static Fields) Technically speaking, objects store their individual states in "non-static fields", that is, fields declared without the static keyword. Non-static fields are also known as instance variables because their values are unique to each instance of a class (to each object, in other words); the currentSpeed of one bicycle is independent from the currentSpeed of another.</li>
      <li>Class Variables (Static Fields) A class variable is any field declared with the static modifier; this tells the compiler that there is exactly one copy of this variable in existence, regardless of how many times the class has been instantiated. A field defining the number of gears for a particular kind of bicycle could be marked as static since conceptually the same number of gears will apply to all instances. The code static int numGears = 6; would create such a static field. Additionally, the keyword final could be added to indicate that the number of gears will never change.</li>
      <li>Local Variables Similar to how an object stores its state in fields, a method will often store its temporary state in local variables. The syntax for declaring a local variable is similar to declaring a field (for example, int count = 0;). There is no special keyword designating a variable as local; that determination comes entirely from the location in which the variable is declared — which is between the opening and closing braces of a method. As such, local variables are only visible to the methods in which they are declared; they are not accessible from the rest of the class.</li>
      <li>Parameters You've already seen examples of parameters, both in the Bicycle class and in the main method of the "Hello World!" application. Recall that the signature for the main method is public static void main(String[] args). Here, the args variable is the parameter to this method. The important thing to remember is that parameters are always classified as "variables" not "fields". This applies to other parameter-accepting constructs as well (such as constructors and exception handlers) that you'll learn about later in the tutorial.</li>
    </ul>
    <p>Every programming language has its own set of rules and conventions for the kinds of names that you're allowed to use, and the Java programming language is no different. The rules and conventions for naming your variables can be summarized as follows:</p>
    <ul>
      <li>Variable names are case-sensitive. A variable's name can be any legal identifier — an unlimited-length sequence of Unicode letters and digits, beginning with a letter, the dollar sign "$", or the underscore character "_". The convention, however, is to always begin your variable names with a letter, not "$" or "_". Additionally, the dollar sign character, by convention, is never used at all. You may find some situations where auto-generated names will contain the dollar sign, but your variable names should always avoid using it. A similar convention exists for the underscore character; while it's technically legal to begin your variable's name with "_", this practice is discouraged. White space is not permitted.</li>
      <li>Subsequent characters may be letters, digits, dollar signs, or underscore characters. Conventions (and common sense) apply to this rule as well. When choosing a name for your variables, use full words instead of cryptic abbreviations. Doing so will make your code easier to read and understand. In many cases it will also make your code self-documenting; fields named cadence, speed, and gear, for example, are much more intuitive than abbreviated versions, such as s, c, and g. Also keep in mind that the name you choose must not be a keyword or reserved word.</li>
      <li>If the name you choose consists of only one word, spell that word in all lowercase letters. If it consists of more than one word, capitalize the first letter of each subsequent word. The names gearRatio and currentGear are prime examples of this convention. If your variable stores a constant value, such as static final int NUM_GEARS = 6, the convention changes slightly, capitalizing every letter and separating subsequent words with the underscore character. By convention, the underscore character is never used elsewhere.</li>
    </ul>
  </section>

  <section id="Operators" class="main-section">
    <h1>Operators</h1>
    <p>Operators are special symbols that perform specific operations on one, two, or three operands, and then return a result.</p>
    <p>As we explore the operators of the Java programming language, it may be helpful for you to know ahead of time which operators have the highest precedence. The operators in the following table are listed according to precedence order. The closer to the top of the table an operator appears, the higher its precedence. Operators with higher precedence are evaluated before operators with relatively lower precedence. Operators on the same line have equal precedence. When operators of equal precedence appear in the same expression, a rule must govern which is evaluated first. All binary operators except for the assignment operators are evaluated from left to right; assignment operators are evaluated right to left.</p>
    <table>
      <thead>
        <th colspan="2">Operators</th>
      </thead>
      <tbody>
        <tr>
          <th>Operators</th>
          <th>Precedence</th>
        </tr>
        <tr>
          <td>postfix</td>
          <td>expr++  expr--</td>
        </tr>
        <tr>
          <td>unary</td>
          <td>++expr  --expr  +expr  -expr  ~  !</td>
        </tr>
        <tr>
          <td>multiplicative</td>
          <td>*  /  %</td>
        </tr>
        <tr>
          <td>additive</td>
          <td>+  -</td>
        </tr>
        <tr>
          <td>shift</td>
          <td><<  >>  >>></td>
        </tr>
        <tr>
          <td>relational</td>
          <td><  >  <=  >=  instanceof</td>
        </tr>
        <tr>
          <td>equality</td>
          <td>==  !=</td>
        </tr>
        <tr>
          <td>bitwise AND</td>
          <td>&</td>
        </tr>
        <tr>
          <td>bitwise exclusive OR</td>
          <td>^</td>
        </tr>
        <tr>
          <td>bitwise inclusive OR</td>
          <td>|</td>
        </tr>
        <tr>
          <td>logical AND</td>
          <td>&&</td>
        </tr>
        <tr>
          <td>logical OR</td>
          <td>||</td>
        </tr>
        <tr>
          <td>ternary</td>
          <td>?  :</td>
        </tr>
        <tr>
          <td>assignment</td>
          <td>=  +=  -=  *=  /=  %=  &=  ^=  |=  <<=  >>=  >>>=</td>
        </tr>
      </tbody>
    </table>
    <p>In general-purpose programming, certain operators tend to appear more frequently than others; for example, the assignment operator "=" is far more common than the unsigned right shift operator ">>>". With that in mind, the following discussion focuses first on the operators that you're most likely to use on a regular basis, and ends focusing on those that are less common. Each discussion is accompanied by sample code that you can compile and run. Studying its output will help reinforce what you've just learned.</p>
  </section>
  <section id="Reference" class="main-section">
    <h1>Reference</h1>
    <ul>
      <li>All the documentation in this page is taken from <a id="source" href="https://docs.oracle.com/javase/tutorial/index.html">Oracle's Java Tutorials</a></li>
    </ul>
  </section>
</main>